import { api } from "./client";
import { ApiError } from "./errors";
import { API_ENDPOINTS } from "./constants";
import { logger } from "../utils/logger";

/**
 * Therapeutic story generated by AI
 */
export interface TherapeuticStory {
  story: string;
  locale: string;
  moodSummary: {
    dominantMood?: string;
    moodTrend?: string;
    dataPointsAnalyzed?: number;
  };
  aiGenerated: boolean;
  modelUsed: string;
  confidence: number;
  wordCount: number;
  generatedAt: string;
}

/**
 * Story history item
 */
export interface StoryHistoryItem {
  id: string;
  storyPreview: string;
  locale: string;
  moodDataPoints: number;
  aiGenerated: boolean;
  modelUsed: string;
  confidence: number;
  generatedAt: string;
}

/**
 * Story history response
 */
export interface StoryHistoryResponse {
  stories: StoryHistoryItem[];
}

/**
 * Mood forecast generated by AI
 */
export interface MoodForecast {
  forecast: {
    predictions?: Array<{
      date: string;
      predictedMood: number;
      confidence: number;
    }>;
    summary?: string;
  };
  modelInfo: {
    algorithm?: string;
    features?: string[];
    accuracy?: number;
  };
  currentAnalysis: {
    currentMood?: number;
    trend?: string;
    stability?: string;
  };
  riskFactors: string[];
  recommendations: string[];
  confidence: number;
  dataPointsUsed: number;
  forecastPeriodDays: number;
  generatedAt: string;
}

/**
 * Forecast history item
 */
export interface ForecastHistoryItem {
  id: string;
  forecastSummary: {
    trendDirection?: string;
    averagePrediction?: number;
    confidenceLevel?: string;
  };
  daysAhead: number;
  modelUsed: string;
  dataPointsUsed: number;
  riskFactors: string[];
  generatedAt: string;
}

/**
 * Forecast history response
 */
export interface ForecastHistoryResponse {
  forecasts: ForecastHistoryItem[];
}

/**
 * Chat response from AI chatbot (supports both camelCase and snake_case)
 */
export interface ChatResponse {
  success?: boolean;
  data?: {
    response: string;
    emotionsDetected?: string[];
    suggestedActions?: string[];
    exerciseRecommendations?: string[];
    crisisDetected?: boolean;
    crisisAnalysis?: Record<string, unknown>;
    aiGenerated?: boolean;
    modelUsed?: string;
    sentimentAnalysis?: {
      sentiment: 'POSITIVE' | 'NEGATIVE' | 'NEUTRAL';
      emotions: string[];
    };
    aiFeatureSuggestions?: {
      suggestStory: boolean;
      suggestForecast: boolean;
      storyReason: string;
      forecastReason: string;
    };
  };
  // Direct response fields (camelCase)
  response: string;
  emotionsDetected?: string[];
  suggestedActions?: string[];
  exerciseRecommendations?: string[];
  crisisDetected?: boolean;
  crisisAnalysis?: Record<string, unknown>;
  aiGenerated?: boolean;
  modelUsed?: string;
  sentimentAnalysis?: {
    sentiment: 'POSITIVE' | 'NEGATIVE' | 'NEUTRAL';
    emotions: string[];
  };
  aiFeatureSuggestions?: {
    suggestStory: boolean;
    suggestForecast: boolean;
    storyReason: string;
    forecastReason: string;
  };
  // Legacy snake_case fields for backward compatibility
  /** @deprecated Use response instead */
  message?: string;
  emotions_detected?: string[];
  /** Alias for emotions_detected for backward compatibility */
  emotions?: string[];
  suggested_actions?: string[];
  exercise_recommendations?: string[];
  crisis_detected?: boolean;
  crisis_analysis?: Record<string, unknown>;
  ai_generated?: boolean;
  model_used?: string;
  sentiment_analysis?: {
    sentiment: 'POSITIVE' | 'NEGATIVE' | 'NEUTRAL';
    emotions: string[];
  };
  /** Shorthand for sentiment_analysis.sentiment */
  sentiment?: 'POSITIVE' | 'NEGATIVE' | 'NEUTRAL';
  ai_feature_suggestions?: {
    suggest_story: boolean;
    suggest_forecast: boolean;
    story_reason: string;
    forecast_reason: string;
  };
}

/**
 * Chat history message (supports both camelCase and snake_case)
 */
export interface ChatHistoryMessage {
  role: 'user' | 'assistant';
  content: string;
  timestamp: string;
  // camelCase fields
  emotionsDetected?: string[];
  suggestedActions?: string[];
  crisisDetected?: boolean;
  crisisAnalysis?: Record<string, unknown>;
  aiGenerated?: boolean;
  modelUsed?: string;
  // Legacy snake_case fields
  emotions_detected?: string[];
  suggested_actions?: string[];
  crisis_detected?: boolean;
  crisis_analysis?: Record<string, unknown>;
  ai_generated?: boolean;
  model_used?: string;
}

/**
 * Exercise session content (supports both camelCase and snake_case)
 */
export interface ExerciseContent {
  title: string;
  description: string;
  // camelCase
  durationMinutes?: number;
  // Legacy snake_case
  duration_minutes?: number;
  steps: string[];
  tips: string;
  benefits: string;
  instructions: string;
}

export interface ExerciseSession {
  success?: boolean;
  data?: {
    exercise: ExerciseContent;
    exerciseType: string;
    duration: number;
    startedAt: string;
  };
  exercise: ExerciseContent;
  // camelCase
  exerciseType?: string;
  startedAt?: string;
  // Legacy snake_case
  exercise_type?: string;
  started_at?: string;
  duration: number;
}

/**
 * Pattern analysis response (supports both camelCase and snake_case)
 */
export interface PatternAnalysisResponse {
  success?: boolean;
  data?: {
    patternAnalysis: {
      pattern_analysis: string;
      predictions: string;
      confidence: number;
    };
    dataPointsAnalyzed: number;
    analysisTimestamp: string;
  };
  // camelCase fields
  patternAnalysis?: {
    pattern_analysis: string;
    predictions: string;
    confidence: number;
  };
  dataPointsAnalyzed?: number;
  analysisTimestamp?: string;
  // Legacy snake_case fields
  pattern_analysis?: {
    pattern_analysis: string;
    predictions: string;
    confidence: number;
  };
  data_points_analyzed?: number;
  analysis_timestamp?: string;
}

/**
 * Chat with AI therapeutic assistant
 * @param userId - User ID (for backward compatibility, now extracted from JWT)
 * @param message - User message
 * @returns Promise resolving to AI response
 * @throws Error if chat fails
 */
export const chatWithAI = async (
  userId: string,
  message: string
): Promise<ChatResponse> => {
  try {
    const response = await api.post<ChatResponse>(API_ENDPOINTS.CHATBOT.CHAT, {
      user_id: userId,
      message,
    });
    // Handle both APIResponse (data wrapper) and direct format
    const raw = response.data as any;
    const data: Record<string, any> = raw.data || raw;
    return {
      response: data.response || '',
      emotionsDetected: data.emotionsDetected || data.emotions_detected || [],
      suggestedActions: data.suggestedActions || data.suggested_actions || [],
      crisisDetected: data.crisisDetected ?? data.crisis_detected ?? false,
      aiGenerated: data.aiGenerated ?? data.ai_generated ?? true,
      modelUsed: data.modelUsed || data.model_used || 'unknown',
    };
  } catch (error: unknown) {
    if (error instanceof ApiError) {
      throw error;
    }
    throw ApiError.fromAxiosError(error);
  }
};

/**
 * Get chat history for user
 * @param userId - User ID (optional, extracted from JWT on backend)
 * @returns Promise resolving to chat history messages
 * @throws Error if history retrieval fails
 */
export const getChatHistory = async (
  _userId?: string
): Promise<{ conversation: ChatHistoryMessage[] }> => {
  try {
    const response = await api.get<{ data?: { conversation: ChatHistoryMessage[] }; conversation?: ChatHistoryMessage[] }>(
      API_ENDPOINTS.CHATBOT.CHAT_HISTORY
    );
    // Handle both APIResponse (data wrapper) and direct format
    const conversation = response.data.data?.conversation || response.data.conversation || [];
    return { conversation };
  } catch (error: unknown) {
    if (error instanceof ApiError) {
      throw error;
    }
    throw ApiError.fromAxiosError(error);
  }
};

/**
 * Analyze mood patterns for user
 * @returns Promise resolving to pattern analysis
 * @throws Error if analysis fails
 */
export const analyzeMoodPatterns = async (): Promise<PatternAnalysisResponse> => {
  try {
    const response = await api.post<PatternAnalysisResponse>(
      API_ENDPOINTS.CHATBOT.ANALYZE_PATTERNS
    );
    // Handle both APIResponse (data wrapper) and direct format
    const raw = response.data as any;
    const data: Record<string, any> = raw.data || raw;
    return {
      patternAnalysis: data.patternAnalysis || data.pattern_analysis,
      dataPointsAnalyzed: data.dataPointsAnalyzed ?? data.data_points_analyzed ?? 0,
      analysisTimestamp: data.analysisTimestamp || data.analysis_timestamp || '',
    };
  } catch (error: unknown) {
    if (error instanceof ApiError) {
      throw error;
    }
    throw ApiError.fromAxiosError(error);
  }
};

/**
 * Start an exercise session
 * @param exerciseType - Type of exercise: 'breathing' | 'mindfulness' | 'cbt_thought_record' | 'gratitude' | 'progressive_relaxation'
 * @param duration - Duration in minutes (1-60)
 * @returns Promise resolving to exercise session
 * @throws Error if exercise start fails
 */
export const startExercise = async (
  exerciseType: 'breathing' | 'mindfulness' | 'cbt_thought_record' | 'gratitude' | 'progressive_relaxation',
  duration: number = 5
): Promise<ExerciseSession> => {
  try {
    const response = await api.post<ExerciseSession>(API_ENDPOINTS.CHATBOT.EXERCISE, {
      exerciseType,  // Send camelCase (backend accepts both)
      duration,
    });
    // Handle both APIResponse (data wrapper) and direct format
    const raw = response.data as any;
    const data: Record<string, any> = raw.data || raw;
    return {
      exercise: data.exercise,
      exerciseType: data.exerciseType || data.exercise_type,
      startedAt: data.startedAt || data.started_at,
      duration: data.duration,
    };
  } catch (error: unknown) {
    if (error instanceof ApiError) {
      throw error;
    }
    throw ApiError.fromAxiosError(error);
  }
};

/**
 * Mark an exercise as completed
 * @param userId - User ID
 * @param exerciseId - Exercise ID
 * @returns Promise resolving to completion response
 * @throws Error if completion fails
 */
export const completeExercise = async (
  userId: string,
  exerciseId: string
): Promise<{ message: string }> => {
  try {
    const response = await api.post<{ message: string }>(
      `${API_ENDPOINTS.CHATBOT.EXERCISE_COMPLETE}/${userId}/${exerciseId}/complete`
    );
    return response.data;
  } catch (error: unknown) {
    if (error instanceof ApiError) {
      throw error;
    }
    throw ApiError.fromAxiosError(error);
  }
};

/**
 * Transcribe audio to text
 * @param audioBlob - Audio blob to transcribe
 * @returns Promise resolving to transcription result
 * @note This endpoint may require additional backend implementation
 */
export const transcribeAudio = async (
  audioBlob: Blob
): Promise<{ text: string; confidence: number }> => {
  try {
    const formData = new FormData();
    formData.append('audio', audioBlob, 'recording.webm');

    const response = await api.post<{ text: string; confidence: number }>(
      API_ENDPOINTS.VOICE.TRANSCRIBE_AUDIO,
      formData,
      {
        headers: {
          'Content-Type': 'multipart/form-data',
        },
      }
    );
    return response.data;
  } catch (error: unknown) {
    // Fallback for unimplemented endpoint
    logger.warn('Audio transcription not available, using fallback');
    return { text: '', confidence: 0 };
  }
};

/**
 * Analyze voice emotion from audio
 * @param audioBlob - Audio blob to analyze
 * @returns Promise resolving to emotion analysis
 * @note This endpoint may require additional backend implementation
 */
export const analyzeVoiceEmotion = async (
  audioBlob: Blob
): Promise<{ emotion: string; confidence: number }> => {
  try {
    const formData = new FormData();
    formData.append('audio', audioBlob, 'recording.webm');

    const response = await api.post<{ emotion: string; confidence: number }>(
      API_ENDPOINTS.VOICE.ANALYZE_VOICE_EMOTION,
      formData,
      {
        headers: {
          'Content-Type': 'multipart/form-data',
        },
      }
    );
    return response.data;
  } catch (error: unknown) {
    // Fallback for unimplemented endpoint
    logger.warn('Voice emotion analysis not available, using fallback');
    return { emotion: 'neutral', confidence: 0.5 };
  }
};

/**
 * Analyze text sentiment and emotions using AI
 * @param text - Text to analyze
 * @returns Promise resolving to analysis result
 */
export const analyzeTextSentiment = async (
  text: string
): Promise<{ sentiment: string; emotions: string[]; confidence: number }> => {
  try {
    // Use the mood analysis endpoint for text sentiment
    const response = await api.post<{ sentiment: string; emotions: string[]; confidence: number }>(
      API_ENDPOINTS.MOOD.ANALYZE_TEXT,
      { text }
    );
    return response.data;
  } catch (error: unknown) {
    // Fallback
    logger.warn('Text analysis not available, using fallback');
    return { sentiment: 'NEUTRAL', emotions: [], confidence: 0.5 };
  }
};

// ==========================================
// NEW: Therapeutic Story & Mood Forecast
// ==========================================

/**
 * Generate therapeutic story based on mood history
 * @param locale - Language locale (sv, en, etc.)
 * @returns Promise resolving to therapeutic story
 * @throws ApiError if generation fails
 */
export const generateTherapeuticStory = async (
  locale?: string
): Promise<TherapeuticStory> => {
  try {
    const response = await api.post<TherapeuticStory>(
      API_ENDPOINTS.AI.GENERATE_STORY,
      { locale: locale || 'sv' }
    );
    return response.data;
  } catch (error: unknown) {
    if (error instanceof ApiError) {
      throw error;
    }
    throw ApiError.fromAxiosError(error);
  }
};

/**
 * Get user's story generation history
 * @returns Promise resolving to story history
 * @throws ApiError if retrieval fails
 */
export const getStoryHistory = async (): Promise<StoryHistoryResponse> => {
  try {
    const response = await api.get<StoryHistoryResponse>(
      API_ENDPOINTS.AI.GET_STORIES
    );
    return response.data;
  } catch (error: unknown) {
    if (error instanceof ApiError) {
      throw error;
    }
    throw ApiError.fromAxiosError(error);
  }
};

/**
 * Generate mood forecast using ML
 * @param daysAhead - Number of days to forecast (default 7)
 * @param useSklearn - Use scikit-learn ML model (default true)
 * @returns Promise resolving to mood forecast
 * @throws ApiError if generation fails
 */
export const generateMoodForecast = async (
  daysAhead: number = 7,
  useSklearn: boolean = true
): Promise<MoodForecast> => {
  try {
    const response = await api.post<MoodForecast>(
      API_ENDPOINTS.AI.GENERATE_FORECAST,
      { daysAhead, useSklearn }
    );
    return response.data;
  } catch (error: unknown) {
    if (error instanceof ApiError) {
      throw error;
    }
    throw ApiError.fromAxiosError(error);
  }
};

/**
 * Get user's forecast history
 * @returns Promise resolving to forecast history
 * @throws ApiError if retrieval fails
 */
export const getForecastHistory = async (): Promise<ForecastHistoryResponse> => {
  try {
    const response = await api.get<ForecastHistoryResponse>(
      API_ENDPOINTS.AI.GET_FORECASTS
    );
    return response.data;
  } catch (error: unknown) {
    if (error instanceof ApiError) {
      throw error;
    }
    throw ApiError.fromAxiosError(error);
  }
};