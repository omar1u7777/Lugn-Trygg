<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Secure Storage - Lugn-Trygg</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            max-width: 800px;
            margin: 50px auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border-left: 4px solid #3498db;
            background: #f8f9fa;
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 6px;
            font-weight: bold;
        }
        .success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px;
        }
        button:hover {
            background: #2980b9;
        }
        button:disabled {
            background: #95a5a6;
            cursor: not-allowed;
        }
        .output {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            margin: 10px 0;
            max-height: 300px;
            overflow-y: auto;
        }
        .test-result {
            margin: 10px 0;
            padding: 10px;
            border-radius: 4px;
        }
        .pass { background: #d4edda; }
        .fail { background: #f8d7da; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîê Secure Storage Test Suite</h1>
        <p>Testing AES-256-GCM encrypted token storage implementation</p>

        <div class="test-section">
            <h3>Test 1: Web Crypto API Availability</h3>
            <button onclick="testCryptoAPI()">Run Test</button>
            <div id="crypto-result"></div>
        </div>

        <div class="test-section">
            <h3>Test 2: Encryption/Decryption</h3>
            <button onclick="testEncryption()">Run Test</button>
            <div id="encryption-result"></div>
        </div>

        <div class="test-section">
            <h3>Test 3: Token Storage & Retrieval</h3>
            <button onclick="testTokenStorage()">Run Test</button>
            <div id="token-result"></div>
        </div>

        <div class="test-section">
            <h3>Test 4: localStorage Inspection</h3>
            <button onclick="inspectLocalStorage()">Inspect Storage</button>
            <div id="storage-result"></div>
        </div>

        <div class="test-section">
            <h3>Test 5: Full Authentication Flow</h3>
            <button onclick="testAuthFlow()">Simulate Login/Logout</button>
            <div id="auth-result"></div>
        </div>

        <div class="output" id="console-output"></div>
    </div>

    <script type="module">
        // Mock encryption key for testing (DO NOT use in production!)
        const TEST_ENCRYPTION_KEY = 'a1b2c3d4e5f6789012345678901234567890abcdefghijklmnopqrstuvwxyz01';

        // Simple secure storage implementation for testing
        class TestSecureStorage {
            constructor(encryptionKey) {
                this.encryptionKeyHex = encryptionKey;
            }

            async getCryptoKey() {
                const keyData = new Uint8Array(
                    this.encryptionKeyHex.match(/.{1,2}/g).map(byte => parseInt(byte, 16))
                );
                return await crypto.subtle.importKey(
                    'raw',
                    keyData,
                    { name: 'AES-GCM', length: 256 },
                    false,
                    ['encrypt', 'decrypt']
                );
            }

            async encrypt(data) {
                try {
                    const key = await this.getCryptoKey();
                    const iv = crypto.getRandomValues(new Uint8Array(12));
                    const encodedData = new TextEncoder().encode(data);
                    
                    const encryptedData = await crypto.subtle.encrypt(
                        { name: 'AES-GCM', iv },
                        key,
                        encodedData
                    );
                    
                    const encryptedArray = new Uint8Array(encryptedData);
                    const combined = new Uint8Array(iv.length + encryptedArray.length);
                    combined.set(iv);
                    combined.set(encryptedArray, iv.length);
                    
                    return btoa(String.fromCharCode.apply(null, combined));
                } catch (error) {
                    log('‚ùå Encryption error: ' + error.message, 'error');
                    throw error;
                }
            }

            async decrypt(encryptedData) {
                try {
                    const key = await this.getCryptoKey();
                    const combined = Uint8Array.from(atob(encryptedData), c => c.charCodeAt(0));
                    const iv = combined.slice(0, 12);
                    const data = combined.slice(12);
                    
                    const decryptedData = await crypto.subtle.decrypt(
                        { name: 'AES-GCM', iv },
                        key,
                        data
                    );
                    
                    return new TextDecoder().decode(decryptedData);
                } catch (error) {
                    log('‚ùå Decryption error: ' + error.message, 'error');
                    throw error;
                }
            }

            async setItem(key, value) {
                const encrypted = await this.encrypt(value);
                localStorage.setItem('secure_' + key, encrypted);
            }

            async getItem(key) {
                const encrypted = localStorage.getItem('secure_' + key);
                if (!encrypted) return null;
                return await this.decrypt(encrypted);
            }

            removeItem(key) {
                localStorage.removeItem('secure_' + key);
            }

            clear() {
                Object.keys(localStorage).forEach(key => {
                    if (key.startsWith('secure_')) {
                        localStorage.removeItem(key);
                    }
                });
            }
        }

        const storage = new TestSecureStorage(TEST_ENCRYPTION_KEY);

        const tokenStorage = {
            async setAccessToken(token) {
                await storage.setItem('token', token);
            },
            async getAccessToken() {
                return await storage.getItem('token');
            },
            async setRefreshToken(token) {
                await storage.setItem('refresh_token', token);
            },
            async getRefreshToken() {
                return await storage.getItem('refresh_token');
            },
            clearTokens() {
                storage.removeItem('token');
                storage.removeItem('refresh_token');
            }
        };

        function log(message, type = 'info') {
            const output = document.getElementById('console-output');
            const timestamp = new Date().toLocaleTimeString();
            const line = `[${timestamp}] ${message}`;
            output.innerHTML += line + '\n';
            output.scrollTop = output.scrollHeight;
            console.log(message);
        }

        window.testCryptoAPI = async function() {
            const result = document.getElementById('crypto-result');
            log('üß™ Testing Web Crypto API availability...');
            
            try {
                if (!window.crypto || !window.crypto.subtle) {
                    throw new Error('Web Crypto API not available');
                }
                
                result.innerHTML = `
                    <div class="status success">
                        ‚úÖ PASS: Web Crypto API is available<br>
                        Supported: crypto.subtle.encrypt, decrypt, importKey
                    </div>
                `;
                log('‚úÖ Web Crypto API test passed');
            } catch (error) {
                result.innerHTML = `
                    <div class="status error">
                        ‚ùå FAIL: ${error.message}
                    </div>
                `;
                log('‚ùå Web Crypto API test failed: ' + error.message, 'error');
            }
        };

        window.testEncryption = async function() {
            const result = document.getElementById('encryption-result');
            log('üß™ Testing encryption/decryption...');
            
            try {
                const testData = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.test_token_12345';
                log(`üìù Original data: ${testData}`);
                
                const encrypted = await storage.encrypt(testData);
                log(`üîí Encrypted (length ${encrypted.length}): ${encrypted.substring(0, 50)}...`);
                
                const decrypted = await storage.decrypt(encrypted);
                log(`üîì Decrypted: ${decrypted}`);
                
                if (decrypted === testData) {
                    result.innerHTML = `
                        <div class="status success">
                            ‚úÖ PASS: Encryption/Decryption successful<br>
                            Original: ${testData.substring(0, 30)}...<br>
                            Encrypted length: ${encrypted.length} bytes<br>
                            Decrypted matches: ‚úì
                        </div>
                    `;
                    log('‚úÖ Encryption test passed');
                } else {
                    throw new Error('Decrypted data does not match original');
                }
            } catch (error) {
                result.innerHTML = `
                    <div class="status error">
                        ‚ùå FAIL: ${error.message}
                    </div>
                `;
                log('‚ùå Encryption test failed: ' + error.message, 'error');
            }
        };

        window.testTokenStorage = async function() {
            const result = document.getElementById('token-result');
            log('üß™ Testing token storage API...');
            
            try {
                const testAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.access_token_12345';
                const testRefreshToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.refresh_token_67890';
                
                log('üíæ Storing access token...');
                await tokenStorage.setAccessToken(testAccessToken);
                
                log('üíæ Storing refresh token...');
                await tokenStorage.setRefreshToken(testRefreshToken);
                
                log('üìñ Retrieving access token...');
                const retrievedAccess = await tokenStorage.getAccessToken();
                
                log('üìñ Retrieving refresh token...');
                const retrievedRefresh = await tokenStorage.getRefreshToken();
                
                const accessMatch = retrievedAccess === testAccessToken;
                const refreshMatch = retrievedRefresh === testRefreshToken;
                
                if (accessMatch && refreshMatch) {
                    result.innerHTML = `
                        <div class="status success">
                            ‚úÖ PASS: Token storage works correctly<br>
                            Access token: ${accessMatch ? '‚úì' : '‚úó'}<br>
                            Refresh token: ${refreshMatch ? '‚úì' : '‚úó'}
                        </div>
                    `;
                    log('‚úÖ Token storage test passed');
                } else {
                    throw new Error('Retrieved tokens do not match stored tokens');
                }
            } catch (error) {
                result.innerHTML = `
                    <div class="status error">
                        ‚ùå FAIL: ${error.message}
                    </div>
                `;
                log('‚ùå Token storage test failed: ' + error.message, 'error');
            }
        };

        window.inspectLocalStorage = function() {
            const result = document.getElementById('storage-result');
            log('üîç Inspecting localStorage...');
            
            const secureKeys = Object.keys(localStorage).filter(k => k.startsWith('secure_'));
            
            if (secureKeys.length === 0) {
                result.innerHTML = `
                    <div class="status info">
                        ‚ÑπÔ∏è No secure storage keys found. Run token storage test first.
                    </div>
                `;
                log('‚ÑπÔ∏è No secure keys in localStorage');
                return;
            }
            
            let html = '<div class="status success">üîê Encrypted data in localStorage:</div>';
            html += '<div class="output">';
            
            secureKeys.forEach(key => {
                const value = localStorage.getItem(key);
                html += `<strong>${key}:</strong><br>`;
                html += `${value.substring(0, 100)}...<br>`;
                html += `Length: ${value.length} bytes<br><br>`;
                log(`üîë ${key}: ${value.length} bytes (encrypted)`);
            });
            
            html += '</div>';
            result.innerHTML = html;
            log('‚úÖ Storage inspection complete');
        };

        window.testAuthFlow = async function() {
            const result = document.getElementById('auth-result');
            log('üß™ Testing full authentication flow...');
            
            try {
                // Step 1: Login (store tokens)
                log('1Ô∏è‚É£ Simulating login...');
                const mockAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.mock_access_' + Date.now();
                const mockRefreshToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.mock_refresh_' + Date.now();
                
                await tokenStorage.setAccessToken(mockAccessToken);
                await tokenStorage.setRefreshToken(mockRefreshToken);
                log('‚úÖ Tokens stored (encrypted)');
                
                // Step 2: Verify tokens in localStorage (encrypted)
                log('2Ô∏è‚É£ Verifying encrypted storage...');
                const rawToken = localStorage.getItem('secure_token');
                if (!rawToken) throw new Error('Token not found in localStorage');
                if (rawToken.includes('mock_access')) throw new Error('Token is not encrypted!');
                log('‚úÖ Token is encrypted in localStorage');
                
                // Step 3: Retrieve and use token (automatic decryption)
                log('3Ô∏è‚É£ Retrieving token (automatic decryption)...');
                const retrievedToken = await tokenStorage.getAccessToken();
                if (retrievedToken !== mockAccessToken) throw new Error('Retrieved token does not match');
                log('‚úÖ Token retrieved and decrypted successfully');
                
                // Step 4: Token refresh
                log('4Ô∏è‚É£ Simulating token refresh...');
                const newAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.refreshed_' + Date.now();
                await tokenStorage.setAccessToken(newAccessToken);
                const refreshedToken = await tokenStorage.getAccessToken();
                if (refreshedToken !== newAccessToken) throw a new Error('Refresh failed');
                log('‚úÖ Token refresh successful');
                
                // Step 5: Logout (clear tokens)
                log('5Ô∏è‚É£ Simulating logout...');
                tokenStorage.clearTokens();
                const afterLogout = await tokenStorage.getAccessToken();
                if (afterLogout !== null) throw new Error('Tokens not cleared');
                log('‚úÖ Tokens cleared successfully');
                
                result.innerHTML = `
                    <div class="status success">
                        ‚úÖ PASS: Full authentication flow works!<br><br>
                        <strong>Test Results:</strong><br>
                        1. Login (store tokens): ‚úì<br>
                        2. Encrypted storage: ‚úì<br>
                        3. Token retrieval: ‚úì<br>
                        4. Token refresh: ‚úì<br>
                        5. Logout (clear tokens): ‚úì
                    </div>
                `;
                log('üéâ All authentication flow tests passed!');
                
            } catch (error) {
                result.innerHTML = `
                    <div class="status error">
                        ‚ùå FAIL: ${error.message}
                    </div>
                `;
                log('‚ùå Authentication flow test failed: ' + error.message, 'error');
            }
        };

        // Auto-run on page load
        window.addEventListener('load', () => {
            log('üöÄ Secure Storage Test Suite loaded');
            log('üìù Click buttons to run tests');
            log('‚ö†Ô∏è  Using mock encryption key for testing only');
        });
    </script>
</body>
</html>
